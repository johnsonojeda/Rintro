g---
title: "Introduction to R | Data Manipulation"
author: "EcoHealth Alliance"
date: "February 1, 2016"
output: html_document
---

<img src = "rlogo.png" style="position:absolute;top:0px;left:0px;"/>

## Contents


[More about dataframes](#df)

[Drop or add columns](#drop)

[Data summary](#dsum)

[Change column names](#colname)

[Subsetting the dataframe](#subset)


## <a name = "df"><a/>Dataframes 

We have learned how to load dataframes and view the different types of data 
structures within them. We will now learn how to explore and manipulate these
dataframes.

The first row in a dataframe is called the *header* and holds all  column (variable) names. 
The first column of the dataframe usually consists of rownames. However, rownames aren't 
always present in dataframes. All rows after the *header* are called *data rows*. 
Each member of a row is called a *cell*. 

We can find out how many rows and columns are in our dataframe.

```{r}
#Using the USMortality dataframe from the lattice package
library(lattice)
data("USMortality")

nrow(USMortality)    # Number of rows in mtcars

ncol(USMortality) # Number of columns in mtcars
```

Likewise, we can take a look at the first (head) and last (tail) elements of the dataframe.
```{r}
head(USMortality) # First 6 elements

tail(USMortality) # Last 6 elements
```

We can also determine the value of a particular cell by specifying the row and column number from which we wish to extract values.

```{r}
USMortality[2,3]   # Value from second row and third column
```

Additionally, we can find out how many elements are within a single column of the dataframe

```{r}
length(USMortality$Cause)
```

### EXERCISE 1

1. Load the in-buitl *iris* dataframe
2. How many rows are in this dataframe? 
3. Get the first 6 elements of the dataframe

***

## <a name = "drop"><a/> Drop or add columns

More often than not, dataframes are not structured in a way that is most practical for our analyses. Handling large dataframes may be complicated, data might lack information that we need, etc. We are able to perform several manipulations to dataframes to make handling data more convenient. 

**Dropping columns:** Large dataframes may be troublesome to handle, and may hold information that is not necessary for our particular analyses. We can easily select columns we wish to delete to make our dataframe more manageable. 

We can modify the dataframe by specifying columns we wish to retain:

```{r}

mort.drop = USMortality[,3:5] # Create new dataframe with columns 3-5 only

head(mort.drop)
```

Another way to do this is by specifying which column is to be dropped preceded by the *minus* (-) sign as follows:

```{r}

mort.drop = USMortality[,-1] # New dataframe without the first column 

names(mort.drop)        # Print column names of the new dataframe
```

**Adding columns** : Other times we might want to add information to a dataframe. This is done with the *cbind* function, as with vectors or matrices. 

Let's assume we wish to add an ID number for each row in the dataframe:

```{r}

IDnumber = 1:nrow(USMortality)           # Create a vector with as many elements as there rows in the dataframe

names(USMortality)                 # Check column names before adding IDnumber

mort.add = cbind(IDnumber, USMortality)  # Add ID column

names(mort.add)             # Column names after adding IDnumber
```

Keep in mind that the order in which you enter the elements in the *cbind* function will determine where the column is added. If the vector is entered first, then it will be the first column of the new dataframe, otherwise it will be the last column. 

###EXCERCISE 3

1. Drop the following columns from the iris dataframe : Sepal.Width, Petal.Width

2. Add an column with IDnumber to the iris dataframe

***

## <a name = "dsum"><a/>Data summary 

Something that could be quite useful to provide a better understanding of our data is to get
a quick statistical summary of our dataframe. 

```{r}

summary(USMortality)
```

The ```summary()``` function allows us to explore the number of counts and 
labels for categorical data and provides information on the distribution of continuous variables (e.g. min, max, mean)


### EXCERCISE 4

1. Summarize the *iris* dataframe
2. What is the maximum Petal lenght? 
3. How setosa individuals are there? 

***

## <a name = "colname"><a/>Change column names

Column and row names can be changed by the colnames() and rownames() functions respectively.

```{r}

mort.head = head(USMortality)  # New data frame with only first 6 rows


colnames(mort.head) = c("col1", "col2", "col3", "col4", "col5")    # Change column names

rownames(mort.head) = c("ID1", "ID2", "ID3", "ID4", "ID5", "ID6") # Change row names

mort.head #print dataframe
```

You can also change the name of a particular column by specifying its number

```{r}
colnames(mort.head)[2]  = "NewColName" # Specifiy the number of the column being renamed

names(mort.head)                       # Print new column names
```

***

## <a name = "subset"><a/>Subsetting the dataframe

There may be times when we might want to manipulate smaller sets of the original dataframe. For example we may be interested only in those entries where the *Rate* is larger than 50.

```{r}

large_rate = USMortality[USMortality$Rate > 50,]  # Get all rows with rate greater than 50
                                                  # The comma is important here

summary(large_rate)

```

Or we might be interested only in Rural areas

```{r}

Rural = USMortality[USMortality$Status == "Rural",] # Get all rows with Status = Rural 
                                                    # The comma is important here

head(Rural)                                         # Print first values of the dataframe
```

However if we use *str*() we will notice that the other levels for statuses have been retained. This happens because Status is a *factor*. 

```{r}
str(Rural)
```
To succesfully subset dataframes by factors we must use *droplevels*(). 

```{r}
Rural = droplevels(USMortality[USMortality$Status == "Rural",]) #The comma is important
str(Rural)
```

Furthermore, we can exclude rows with certain values by using logical operators. For example, we will retrieve all entries where Cause is not cancer.

```{r}

other.cause = droplevels(USMortality[USMortality$Cause != "Cancer",]) # Get all rows with Cause different from cancer
                                                                      # != means different than
summary(other.cause)
```

### EXCERCISE

Using the *iris* dataframe create different subsets for:

1. All flowers with petals longer than 4mm

2. Flowers with petal widths smaller than 1mm

3. All species except *virginica*



